Object subclass: #PPMemento	instanceVariableNames: 'result count position'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Core'!!PPMemento commentStamp: '<historical>' prior: 0!PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.Instance Variables:	result	<Object>	The cached result.	count	<Integer>	The number of recursive cycles followed.	position	<Integer>	The position of the cached result in the input stream.!!PPMemento methodsFor: 'accessing-readonly' stamp: 'lr 4/22/2008 18:23'!count	^ count! !!PPMemento methodsFor: 'actions' stamp: 'lr 4/22/2008 18:20'!increment	count := count + 1! !!PPMemento methodsFor: 'initialization' stamp: 'lr 4/22/2008 18:21'!initialize	count := 0	! !!PPMemento methodsFor: 'accessing' stamp: 'lr 4/22/2008 18:23'!position	^ position! !!PPMemento methodsFor: 'accessing' stamp: 'lr 4/26/2008 15:48'!position: anInteger	position := anInteger! !!PPMemento methodsFor: 'accessing' stamp: 'lr 4/24/2008 10:15'!result	^ result! !!PPMemento methodsFor: 'accessing' stamp: 'lr 4/22/2008 18:23'!result: anObject	result := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPMemento class	instanceVariableNames: ''!!PPMemento class methodsFor: 'instance creation' stamp: 'lr 4/22/2008 18:21'!new	^ self basicNew initialize! !ReadStream subclass: #PPStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Core'!!PPStream commentStamp: '<historical>' prior: 0!A positional stream implementation used for parsing. It overrides some methods for optimization reasons.!!PPStream methodsFor: 'converting' stamp: 'lr 2/7/2010 20:53'!asPetitStream	^ self! !!PPStream methodsFor: 'accessing' stamp: 'lr 2/13/2012 20:25'!collection	"Answer the underlying collection."		^ collection! !!PPStream methodsFor: 'accessing' stamp: 'lr 4/29/2008 21:48'!peek	"An improved version of peek, that is slightly faster than the built in version."	^ self atEnd ifFalse: [ collection at: position + 1 ]! !!PPStream methodsFor: 'accessing' stamp: 'lr 8/25/2010 11:36'!position: anInteger	"The receiver does not check for invalid arguments passed to this method, as it is solely used with valid indexes for backtracking."	position := anInteger! !!PPStream methodsFor: 'accessing' stamp: 'lr 10/5/2010 16:29'!uncheckedPeek	"An unchecked version of peek that throws an error if we try to peek over the end of the stream, even faster than #peek."	^ collection at: position + 1! !!PPStream methodsFor: 'printing' stamp: 'lr 11/4/2010 19:23'!printOn: aStream	collection isString		ifFalse: [ ^ super printOn: aStream ].	aStream		nextPutAll: (collection copyFrom: 1 to: position);		nextPutAll: '·';		nextPutAll: (collection copyFrom: position + 1 to: readLimit)! !Object subclass: #PPToken	instanceVariableNames: 'collection start stop value'	classVariableNames: 'NewLineParser'	poolDictionaries: ''	category: 'PetitParser-Core'!!PPToken commentStamp: 'lr 2/25/2013 23:34' prior: 0!PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection, its start and stop position and its parse value.Instance Variables:	collection	<SequenceableCollection>	The collection this token comes from.	start	<Integer>	The start position in the collection.	stop	<Integer>	The stop position in the collection.	value <Object>	The parse result.!!PPToken methodsFor: 'comparing' stamp: 'lr 2/26/2013 00:34'!= anObject	^ self class = anObject class and: [ self parsedValue = anObject parsedValue ]! !!PPToken methodsFor: 'comparing' stamp: 'lr 2/26/2013 00:34'!hash	^ self parsedValue hash! !!PPToken methodsFor: 'accessing' stamp: 'lr 6/15/2010 23:34'!collection	"Answer the underlying collection of this token."	^ collection! !!PPToken methodsFor: 'accessing' stamp: 'lr 2/25/2013 23:56'!size	"Answer the size of this token in the underlying collection."	^ stop - start + 1! !!PPToken methodsFor: 'accessing' stamp: 'lr 6/15/2010 23:33'!start	"Answer the start position of this token in the underlying collection."	^ start! !!PPToken methodsFor: 'accessing' stamp: 'lr 6/15/2010 23:33'!stop	"Answer the stop position of this token in the underlying collection."		^ stop! !!PPToken methodsFor: 'querying' stamp: 'lr 9/7/2011 20:40'!column	"Answer the column number of this token in the underlying collection."		| position |	position := 0.	(NewLineParser , [ :stream |		start <= stream position			ifTrue: [ ^ start - position ].		position := stream position ] asParser		/ #any asParser) star			parse: collection.	 ^ start - position! !!PPToken methodsFor: 'querying' stamp: 'lr 9/7/2011 20:41'!line	"Answer the line number of this token in the underlying collection."		| line |	line := 1.	(NewLineParser , [ :stream |		start <= stream position			ifTrue: [ ^ line ].		line := line + 1 ] asParser		/ #any asParser) star			parse: collection.	^ line! !!PPToken methodsFor: 'copying' stamp: 'lr 2/26/2013 00:34'!copyFrom: aStartInteger to: aStopInteger	^ self class on: collection start: start + aStartInteger - 1 stop: stop + aStopInteger - 3 value: value! !!PPToken methodsFor: 'initialization' stamp: 'lr 2/25/2013 23:36'!initializeOn: aSequenceableCollection start: aStartInteger stop: aStopInteger value: anObject	collection := aSequenceableCollection.	start := aStartInteger.	stop := aStopInteger.	value := anObject! !!PPToken methodsFor: 'accessing-values' stamp: 'lr 2/26/2013 00:32'!inputValue	"Answer the consumed input of this token."	^ collection copyFrom: start to: stop! !!PPToken methodsFor: 'accessing-values' stamp: 'lr 2/26/2013 00:32'!parsedValue	"Answer the parsed value of this token."	^ value! !!PPToken methodsFor: 'accessing-values' stamp: 'lr 2/26/2013 00:34'!value	self notify: 'Token>>#value is no longer supported. Instead use Token>>#inputValue or the more pragmatic #parsedValue.'.	^ self inputValue! !!PPToken methodsFor: 'printing' stamp: 'lr 2/26/2013 00:37'!printOn: aStream	super printOn: aStream.	aStream nextPut: $[; print: self start; nextPut: $,; print: self stop; nextPut: $].	aStream nextPut: $(; print: self parsedValue; nextPut: $)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPToken class	instanceVariableNames: ''!!PPToken class methodsFor: 'initialization' stamp: 'lr 11/29/2011 20:42'!initialize	"Platform independent newline sequence. LF: Unix, CR+LF: Windows, and CR: Apple."	NewLineParser := (Character lf asParser) / (Character cr asParser , Character lf asParser optional)! !!PPToken class methodsFor: 'instance creation' stamp: 'lr 4/6/2010 20:58'!new	self error: 'Token can only be created using a dedicated constructor.'! !!PPToken class methodsFor: 'instance creation' stamp: 'lr 2/25/2013 23:36'!on: aSequenceableCollection	^ self on: aSequenceableCollection start: 1 stop: aSequenceableCollection size value: nil! !!PPToken class methodsFor: 'instance creation' stamp: 'lr 2/25/2013 23:39'!on: aSequenceableCollection start: aStartInteger stop: aStopInteger value: anObject	^ self basicNew 		initializeOn: aSequenceableCollection		start: aStartInteger stop: aStopInteger		value: anObject! !Object subclass: #PPFailure	instanceVariableNames: 'message position'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Core'!!PPFailure commentStamp: '<historical>' prior: 0!The failure object in PetitParser. It is the only class that responds to #isPetitFailure with true. It contains an error message and a position of the occurrence of the failure.Instance Variables:	message	<String>	The error message of this failure.	position	<Integer>	The position of this failure in the input stream.!!PPFailure methodsFor: 'initialization' stamp: 'lr 5/5/2010 13:55'!initializeMessage: aString at: anInteger	message := aString.	position := anInteger! !!PPFailure methodsFor: 'testing' stamp: 'lr 2/7/2010 20:54'!isPetitFailure	"I am the only class that should implement this method to return true."	^ true! !!PPFailure methodsFor: 'accessing' stamp: 'lr 5/5/2010 13:56'!message	"Answer a human readable error message of this parse failure."		^ message! !!PPFailure methodsFor: 'accessing' stamp: 'lr 5/5/2010 13:55'!position	"Answer the position in the source string that caused this parse failure."	^ position! !!PPFailure methodsFor: 'printing' stamp: 'lr 5/5/2010 14:01'!printOn: aStream	aStream nextPutAll: self message; nextPutAll: ' at '; print: position! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPFailure class	instanceVariableNames: ''!!PPFailure class methodsFor: 'instance creation' stamp: 'lr 5/5/2010 13:56'!message: aString at: anInteger	^ self basicNew initializeMessage: aString at: anInteger! !PPToken initialize!'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!Stream methodsFor: '*petitparser-core-converting' stamp: 'lr 4/8/2010 14:46'!asPetitStream	^ self contents asPetitStream! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!Character methodsFor: '*petitparser-core-operators' stamp: 'lr 6/12/2010 09:04'!- aCharacter	"Create a range of characters between the receiver and the argument."		^ PPPredicateObjectParser between: self and: aCharacter! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!Character methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:58'!asParser	"Answer a parser that accepts the receiving character."		^ PPLiteralObjectParser on: self! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!Text methodsFor: '*petitparser-core-converting' stamp: 'lr 2/7/2010 20:53'!asPetitStream	^ string asPetitStream! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!Collection methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:38'!asChoiceParser	^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!Collection methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:38'!asSequenceParser	^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!Symbol methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:58'!asParser	"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."	^ PPPredicateObjectParser perform: self! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!BlockClosure methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:48'!asParser	"Answer a parser implemented in the receiving one-argument block."	^ PPPluggableParser on: self! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!Object methodsFor: '*petitparser-core-testing' stamp: 'lr 8/6/2010 16:44'!isPetitParser	^ false! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!Object methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:58'!asParser	"Answer a parser accepting the receiving object."	^ PPPredicateObjectParser expect: self! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!Object methodsFor: '*petitparser-core-testing' stamp: 'lr 2/7/2010 20:54'!isPetitFailure	^ false! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!SequenceableCollection methodsFor: '*petitparser-core-converting' stamp: 'lr 2/7/2010 20:53'!asPetitStream	^ PPStream on: self! !'From Pharo2.0 of 7 March 2013 [Latest update: #20625] on 11 November 2013 at 3:01:05 pm'!!String methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:48'!asParser	"Answer a parser that accepts the receiving string."	^ PPLiteralSequenceParser on: self! !
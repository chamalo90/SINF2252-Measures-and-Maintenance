Object subclass: #PPParser	instanceVariableNames: 'properties'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPParser commentStamp: '<historical>' prior: 0!An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.Instance Variables:	properties	<Dictionary>	Stores additional state in the parser object.!!PPParser methodsFor: 'operators' stamp: 'lr 9/23/2008 18:32'!, aParser 	"Answer a new parser that parses the receiver followed by aParser."	^ PPSequenceParser with: self with: aParser! !!PPParser methodsFor: 'operators' stamp: 'lr 4/14/2010 11:46'!/ aParser 	"Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice)."		^ PPChoiceParser with: self with: aParser! !!PPParser methodsFor: 'operators' stamp: 'lr 5/31/2010 15:12'!and	"Answer a new parser (logical and-predicate) that succeeds whenever the receiver does, but never consumes input."	^ PPAndParser on: self! !!PPParser methodsFor: 'operators' stamp: 'lr 12/3/2010 11:34'!def: aParser	"Redefine the receiver as the argument aParser. This method is useful when defining recursive parsers: instantiate a PPUnresolvedParser and later redefine it with another one."	^ self becomeForward: (aParser name: self name)! !!PPParser methodsFor: 'operators' stamp: 'lr 4/30/2010 12:13'!end	"Answer a new parser that succeeds at the end of the input and return the result of the receiver."	^ PPEndOfInputParser on: self! !!PPParser methodsFor: 'operators' stamp: 'lr 5/31/2010 16:34'!memoized	"Answer a new memoized parser, for refraining redundant computations. This ensures polynomial time O(n^4) for left-recursive grammars and O(n^3) for non left-recursive grammars in the worst case. Not necessary for most grammars that are carefully written and in O(n) anyway."		^ PPMemoizedParser on: self! !!PPParser methodsFor: 'operators' stamp: 'lr 2/19/2010 07:36'!negate	"Answer a new parser consumes any input token but the receiver."		^ self not , #any asParser ==> #second! !!PPParser methodsFor: 'operators' stamp: 'lr 5/31/2010 15:12'!not	"Answer a new parser (logical not-predicate) that succeeds whenever the receiver fails, but never consumes input."	^ PPNotParser on: self! !!PPParser methodsFor: 'operators' stamp: 'lr 9/1/2010 22:03'!optional	"Answer a new parser that parses the receiver, if possible."	^ PPOptionalParser on: self! !!PPParser methodsFor: 'operators' stamp: 'lr 10/23/2008 14:05'!wrapped	"Answer a new parser that is simply wrapped."		^ PPDelegateParser on: self! !!PPParser methodsFor: 'operators' stamp: 'lr 4/14/2010 11:53'!| aParser	"Answer a new parser that either parses the receiver or aParser. Fail if both pass or fail (exclusive choice, unordered choice)."	^ (self not , aParser) / (aParser not , self) ==> #second! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 5/12/2010 20:32'!==> aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PPActionParser on: self block: aBlock! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 6/12/2010 10:20'!>=> aBlock	"Answer a new parser that wraps the receiving parser with a two argument block. The first argument is the parsed stream, the second argument a continuation block on the delegate parser."	^ PPWrappingParser on: self block: aBlock! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 2/19/2010 07:42'!answer: anObject	"Answer a new parser that always returns anObject from a successful parse."	^ self ==> [ :nodes | anObject ]! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 5/15/2008 16:08'!flatten	"Answer a new parser that flattens the underlying collection."		^ PPFlattenParser on: self! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 4/3/2011 15:00'!foldLeft: aBlock	"Answer a new parser that that folds the result of the receiver from left-to-right into aBlock. The argument aBlock must take two or more arguments."		| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==> [ :nodes |		args at: 1 put: nodes first.		2 to: nodes size by: size - 1 do: [ :index |			args				replaceFrom: 2 to: size with: nodes startingAt: index;				at: 1 put: (aBlock valueWithArguments: args) ].		args first ]! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 4/3/2011 14:59'!foldRight: aBlock	"Answer a new parser that that folds the result of the receiver from right-to-left into aBlock. The argument aBlock must take two or more arguments."	| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==> [ :nodes |		args at: size put: nodes last.		nodes size - size + 1 to: 1 by: 1 - size do: [ :index |			args				replaceFrom: 1 to: size - 1 with: nodes startingAt: index;				at: size put: (aBlock valueWithArguments: args) ].		args at: size ]! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 5/6/2011 20:28'!map: aBlock	"Answer a new parser that works on the receiving sequence an passes in each element as a block argument."		^ aBlock numArgs = 1		ifTrue: [ self ==> aBlock ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 6/29/2010 14:25'!token	"Answer a new parser that transforms the input to a token."		^ PPTokenParser on: self! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 4/6/2010 19:26'!token: aTokenClass	"Answer a new parser that transforms the input to a token of class aTokenClass."		^ self token tokenClass: aTokenClass! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/31/2010 12:06'!trim	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpaces! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/11/2011 11:03'!trim: aParser	"Answer a new parser that consumes and ignores aParser repeatedly before and after the receiving parser."		^ PPTrimmingParser on: self trimmer: aParser! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/11/2011 11:03'!trimBlanks	"Answer a new parser that consumes blanks before and after the receiving parser."		^ self trim: #blank asParser! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/11/2011 11:03'!trimSpaces	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trim: #space asParser! !!PPParser methodsFor: '*petitanalyzer-named' stamp: 'lr 11/23/2010 10:01'!allNamedParsers	"Answer all the named parse nodes of the receiver."	| result |	result := OrderedCollection new.	self allNamedParsersDo: [ :parser | result addLast: parser ].	^ result! !!PPParser methodsFor: '*petitanalyzer-named' stamp: 'lr 11/23/2010 10:12'!allNamedParsersDo: aBlock	"Iterate over all the named parse nodes of the receiver."	self allParsersDo: [ :each | 		each name notNil			ifTrue: [ aBlock value: each ] ]! !!PPParser methodsFor: '*petitanalyzer-named' stamp: 'lr 12/3/2010 16:45'!innerChildren	"Answer the inner children of the receiver."	| result |	result := OrderedCollection new.	self innerChildrenDo: [ :parser | result addLast: parser ].	^ result! !!PPParser methodsFor: '*petitanalyzer-named' stamp: 'lr 12/3/2010 16:48'!innerChildrenDo: aBlock	"Iterate over the inner children of the receiver."	self innerChildrenDo: aBlock seen: IdentitySet new! !!PPParser methodsFor: '*petitanalyzer-named' stamp: 'lr 12/3/2010 16:51'!innerChildrenDo: aBlock seen: aSet	"Iterate over the inner children of the receiver."		self children do: [ :each |		(aSet includes: each)			ifTrue: [ ^ self ].		aSet add: each.		each name isNil ifTrue: [			aBlock value: each.			each innerChildrenDo: aBlock seen: aSet ] ]! !!PPParser methodsFor: '*petitanalyzer-named' stamp: 'lr 11/23/2010 10:55'!namedChildren	"Answer the named children of the receiver."	| result |	result := OrderedCollection new.	self namedChildrenDo: [ :parser | result addLast: parser ].	^ result! !!PPParser methodsFor: '*petitanalyzer-named' stamp: 'lr 11/23/2010 10:55'!namedChildrenDo: aBlock	"Iterate over the named children of the receiver."	self namedChildrenDo: aBlock seen: IdentitySet new! !!PPParser methodsFor: '*petitanalyzer-named' stamp: 'lr 11/23/2010 10:55'!namedChildrenDo: aBlock seen: aSet	"Iterate over the named children of the receiver."		self children do: [ :each |		(aSet includes: each)			ifTrue: [ ^ self ].		aSet add: each.		each name isNil			ifTrue: [ each namedChildrenDo: aBlock seen: aSet ]			ifFalse: [ aBlock value: each ] ]! !!PPParser methodsFor: '*petitanalyzer-enumerating' stamp: 'lr 4/13/2010 08:36'!allParsers	"Answer all the parse nodes of the receiver."	| result |	result := OrderedCollection new.	self allParsersDo: [ :parser | result addLast: parser ].	^ result! !!PPParser methodsFor: '*petitanalyzer-enumerating' stamp: 'lr 4/13/2010 08:36'!allParsersDo: aBlock	"Iterate over all the parse nodes of the receiver."	self allParsersDo: aBlock seen: IdentitySet new! !!PPParser methodsFor: '*petitanalyzer-enumerating' stamp: 'lr 4/13/2010 08:35'!allParsersDo: aBlock seen: aSet	"Iterate over all the parse nodes of the receiver, do not visit and follow the ones contained in aSet."	(aSet includes: self)		ifTrue: [ ^ self ].	aSet add: self.	aBlock value: self.	self children		do: [ :each | each allParsersDo: aBlock seen: aSet ]! !!PPParser methodsFor: 'converting' stamp: 'lr 11/29/2011 20:48'!asParser	"Answer the receiving parser."		^ self! !!PPParser methodsFor: 'accessing' stamp: 'lr 10/21/2009 16:38'!children	"Answer a set of child parsers that could follow the receiver."	^ #()! !!PPParser methodsFor: 'accessing' stamp: 'lr 4/19/2010 10:35'!name	"Answer the production name of the receiver."		^ self propertyAt: #name ifAbsent: [ nil ]! !!PPParser methodsFor: 'accessing' stamp: 'lr 4/19/2010 10:38'!name: aString	self propertyAt: #name put: aString! !!PPParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 4/30/2010 07:49'!copyInContext: aDictionary	^ self copyInContext: aDictionary seen: IdentityDictionary new! !!PPParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 7/17/2011 11:53'!copyInContext: aDictionary seen: aSeenDictionary	| copy |	aSeenDictionary 		at: self 		ifPresent: [ :value | ^ value ].	copy := aSeenDictionary		at: self		put: self copy.	copy children do: [ :each |		copy			replace: each			with: (each copyInContext: aDictionary seen: aSeenDictionary) ].	^ copy! !!PPParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 4/29/2010 23:14'!match: aParser inContext: aDictionary	^ self match: aParser inContext: aDictionary seen: IdentitySet new! !!PPParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 6/18/2010 14:09'!match: aParser inContext: aDictionary seen: anIdentitySet	"This is the default implementation to match two parsers. This code can properly handle recursion. This is code is supposed to be overridden in subclasses that add new state."	(self == aParser or: [ anIdentitySet includes: self ])		ifTrue: [ ^ true ].	anIdentitySet add: self.	^ self class = aParser class and: [ self matchList: self children against: aParser children inContext: aDictionary seen: anIdentitySet ]! !!PPParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 4/29/2010 23:07'!matchList: matchList against: parserList inContext: aDictionary seen: aSet	^ self matchList: matchList index: 1 against: parserList index: 1 inContext: aDictionary seen: aSet! !!PPParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 5/31/2010 18:37'!matchList: matchList index: matchIndex against: parserList index: parserIndex inContext: aDictionary seen: aSet	| parser currentIndex currentDictionary currentSeen parsers |	matchList size < matchIndex		ifTrue: [ ^ parserList size < parserIndex ].	parser := matchList at: matchIndex.	parser class = PPListPattern ifTrue: [		currentIndex := parserIndex - 1.		[ currentDictionary := aDictionary copy.		currentSeen := aSet copy.		parserList size < currentIndex or: [ 			parsers := parserList copyFrom: parserIndex to: currentIndex.			(currentDictionary at: parser ifAbsentPut: [ parsers ]) = parsers and: [ 				(self					matchList: matchList					index: matchIndex + 1					against: parserList					index: currentIndex + 1					inContext: currentDictionary					seen: currentSeen)					ifTrue: [ 						currentDictionary keysAndValuesDo: [ :key :value | aDictionary at: key put: value ].						^ true ].				false ] ] ] whileFalse: [ currentIndex := currentIndex + 1 ].		^ false ].	parserList size < parserIndex		ifTrue: [ ^ false ].	(parser match: (parserList at: parserIndex) inContext: aDictionary seen: aSet)		ifFalse: [ ^ false ].	^ self		matchList: matchList		index: matchIndex + 1		against: parserList		index: parserIndex + 1		inContext: aDictionary		seen: aSet! !!PPParser methodsFor: '*petitanalyzer-querying' stamp: 'lr 11/19/2009 23:49'!cycleSet	"Answer a set of all nodes that are within one or more cycles of left-recursion. This is generally not a problem if at least one of the nodes is memoized, but it might make the grammar very inefficient and should be avoided if possible."		| cycles |	cycles := IdentitySet new.	self cycleSet: OrderedCollection new firstSets: self firstSets into: cycles.	^ cycles! !!PPParser methodsFor: '*petitanalyzer-querying' stamp: 'lr 10/22/2009 19:59'!firstSet	"Answer the first-set of the receiver. Note, this implementation is inefficient when called on different receivers of the same grammar, instead use #firstSets to calculate the first-sets at once."		^ self firstSets at: self! !!PPParser methodsFor: '*petitanalyzer-querying' stamp: 'JanKurs 5/31/2013 11:49'!firstSets	"Answer a dictionary with all the parsers reachable from the receiver as key and their first-set as value. The first-set of a parser is the list of terminal parsers that begin the parser derivable from that parser."		| firstSets |	firstSets := IdentityDictionary new.	self allParsersDo: [ :each |		firstSets at: each put: (each isFirstSetTerminal			ifTrue: [ IdentitySet with: each ]			ifFalse: [ IdentitySet new ]).		each isNullable			ifTrue: [ (firstSets at: each) add: PPSentinel instance ] ].	[	| changed tally |		changed := false.		firstSets keysAndValuesDo: [ :parser :first |			tally := first size.			parser firstSets: firstSets into: first.			changed := changed or: [ tally ~= first size ] ].		changed ] whileTrue.	^ firstSets! !!PPParser methodsFor: '*petitanalyzer-querying' stamp: 'lr 11/12/2009 21:13'!followSet	"Answer the follow-set of the receiver starting at the receiver. Note, this implementation is inefficient when called on different receivers of the same grammar, instead use #followSets to calculate the follow-sets at once."	^ self followSets at: self! !!PPParser methodsFor: '*petitanalyzer-querying' stamp: 'lr 9/16/2010 17:55'!followSets	"Answer a dictionary with all the parsers reachable from the receiver as key and their follow-set as value. The follow-set of a parser is the list of terminal parsers that can appear immediately to the right of that parser."		| current previous continue firstSets followSets |	current := previous := 0.	firstSets := self firstSets.	followSets := IdentityDictionary new.	self allParsersDo: [ :each | followSets at: each put: IdentitySet new ].	(followSets at: self) add: PPSentinel instance.	[	followSets keysAndValuesDo: [ :parser :follow |			parser 				followSets: followSets				firstSets: firstSets				into: follow ].		current := followSets			inject: 0			into: [ :result :each | result + each size ].		continue := previous < current.		previous := current.		continue ] whileTrue.	^ followSets! !!PPParser methodsFor: '*petitanalyzer-private' stamp: 'lr 11/19/2009 23:47'!cycleSet: aDictionary	"PRIVATE: Answer the children that could be part of a cycle-set with the receiver, subclasses might restrict the number of children returned. aDictionary is pre-calcualted first-sets."	^ self children! !!PPParser methodsFor: '*petitanalyzer-private' stamp: 'lr 5/22/2010 10:45'!cycleSet: aStack firstSets: aDictionary into: aSet	"PRIVATE: Try to find a cycle, where aStack contains the previously visited parsers. The method returns quickly when the receiver is a terminal, terminals cannot be part of a cycle. If aStack already contains the receiver, then we are in a cycle. In this case we don't process the children further and add the nodes to aSet."	| index |	self isTerminal		ifTrue: [ ^ self ].		(index := aStack indexOf: self) > 0		ifTrue: [ ^ aSet addAll: (aStack copyFrom: index to: aStack size) ].	aStack addLast: self.	(self cycleSet: aDictionary)		do: [ :each | each cycleSet: aStack firstSets: aDictionary into: aSet ].	aStack removeLast! !!PPParser methodsFor: '*petitanalyzer-private' stamp: 'lr 11/12/2009 21:25'!firstSets: aFirstDictionary into: aSet	"PRIVATE: Try to add additional elements to the first-set aSet of the receiver, use the incomplete aFirstDictionary."	self children do: [ :parser | aSet addAll: (aFirstDictionary at: parser) ]! !!PPParser methodsFor: '*petitanalyzer-private' stamp: 'lr 11/12/2009 21:25'!followSets: aFollowDictionary firstSets: aFirstDictionary into: aSet	"PRIVATE: Try to add additional elements to the follow-set aSet of the receiver, use the incomplete aFollowDictionary and the complete aFirstDictionary."		self children do: [ :parser | (aFollowDictionary at: parser) addAll: aSet ]! !!PPParser methodsFor: 'operators-convenience' stamp: 'lr 2/19/2010 07:42'!delimitedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated and possibly ended by aParser."		^ (self separatedBy: aParser) , (aParser optional) ==> [ :node |		node second isNil			ifTrue: [ node first ]			ifFalse: [ node first copyWith: node second ] ]! !!PPParser methodsFor: 'operators-convenience' stamp: 'lr 2/19/2010 07:56'!separatedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated by aParser."		^ (PPSequenceParser with: self with: (PPSequenceParser with: aParser with: self) star) ==> [ :nodes |		| result |		result := Array new: 2 * nodes second size + 1.		result at: 1 put: nodes first.		nodes second 			keysAndValuesDo: [ :index :pair | result replaceFrom: 2 * index to: 2 * index + 1 with: pair startingAt: 1 ].		result ]! !!PPParser methodsFor: 'operators-convenience' stamp: 'lr 2/25/2012 16:54'!withoutSeparators	"Filters out the separators from a parse result produced by one of the productions #delimitedBy: or #separatedBy:."		^ self ==> [ :items |		| result |		result := Array new: items size + 1 // 2.		1 to: result size do: [ :index | result at: index put: (items at: 2 * index - 1) ].		result ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:33'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:33'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:33'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer! !!PPParser methodsFor: 'initialization' stamp: 'lr 4/24/2008 10:33'!initialize! !!PPParser methodsFor: '*petitanalyzer-testing' stamp: 'JanKurs 5/31/2013 11:49'!isFirstSetTerminal	"Answer true if the receiver is a terminal or leaf parser, that means it does not delegate to any other parser."	^ self children isEmpty! !!PPParser methodsFor: '*petitanalyzer-testing' stamp: 'lr 11/12/2009 17:25'!isNullable	"Answer true if the receiver is a nullable parser, e.g. it can successfully parse nothing."		^ false! !!PPParser methodsFor: '*petitanalyzer-testing' stamp: 'lr 5/22/2010 10:45'!isTerminal	"Answer true if the receiver is a terminal or leaf parser, that means it does not delegate to any other parser."	^ self children isEmpty! !!PPParser methodsFor: 'testing' stamp: 'lr 8/6/2010 16:44'!isPetitParser	^ true! !!PPParser methodsFor: 'testing' stamp: 'lr 10/27/2008 11:28'!isUnresolved	^ false! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/8/2010 00:30'!matches: anObject	"Answer if anObject can be parsed by the receiver."		^ (self parse: anObject) isPetitFailure not! !!PPParser methodsFor: 'parsing' stamp: 'lr 6/4/2011 18:12'!matchesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answered an OrderedCollection of the matched parse-trees."	| result |	result := OrderedCollection new.	self 		matchesIn: anObject		do: [ :each | result addLast: each ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 3/1/2010 21:51'!matchesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Make sure to always consume exactly one character with each step, to not miss any match."	((self and ==> aBlock , #any asParser) / #any asParser) star parse: anObject! !!PPParser methodsFor: 'parsing' stamp: 'lr 8/16/2011 07:26'!matchesSkipIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of the matched parse-trees. Skip over matches."	| result |	result := OrderedCollection new.	self 		matchesSkipIn: anObject		do: [ :each | result addLast: each ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 8/16/2011 07:26'!matchesSkipIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Skip over matches."	(self ==> aBlock / #any asParser) star parse: anObject! !!PPParser methodsFor: 'parsing' stamp: 'lr 6/4/2011 18:12'!matchingRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingRangesIn: anObject		do: [ :value | result addLast: value ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/25/2013 23:41'!matchingRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock with the range of each match (index of first character to: index of last character)."	self token		matchesIn: anObject		do: [ :token | aBlock value: (token start to: token stop) ]! !!PPParser methodsFor: 'parsing' stamp: 'DamienCassou 10/29/2011 19:18'!matchingSkipRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingSkipRangesIn: anObject		do: [ :value | result addLast: value ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/25/2013 23:42'!matchingSkipRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Evaluate aBlock with the range of each match (index of first character to: index of last character)."		self token		matchesSkipIn: anObject		do: [ :token | aBlock value: (token start to: token stop) ]! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:53'!parse: anObject	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."		^ self parseOn: anObject asPetitStream! !!PPParser methodsFor: 'parsing' stamp: 'lr 10/29/2010 17:05'!parse: anObject onError: aBlock	"Parse anObject with the receiving parser and answer the parse-result or answer the result of evaluating aBlock. Depending on the number of arguments of the block it is simply evaluated, evaluated with the failure object, or evaluated with the error message and position."		| result |	result := self parse: anObject.	result isPetitFailure		ifFalse: [ ^ result ].	aBlock numArgs = 0		ifTrue: [ ^ aBlock value ].	aBlock numArgs = 1		ifTrue: [ ^ aBlock value: result ].	^ aBlock value: result message value: result position! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 22:18'!parseOn: aStream	"Parse aStream with the receiving parser and answer the parse-result or an instance of PPFailure. Override this method in subclasses to specify custom parse behavior. Do not call this method from outside, instead use #parse:."		self subclassResponsibility! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:03'!max: anInteger	"Answer a new parser that parses the receiver at most anInteger times."		^ self star setMax: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:56'!max: anInteger greedy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMax: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:57'!max: anInteger lazy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMax: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:02'!min: anInteger	"Answer a new parser that parses the receiver at least anInteger times."		^ self star setMin: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:56'!min: anInteger greedy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:57'!min: anInteger lazy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:03'!min: aMinInteger max: aMaxInteger	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times."		^ self star setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:56'!min: aMinInteger max: aMaxInteger greedy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:57'!min: aMinInteger max: aMaxInteger lazy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:03'!plus	"Answer a new parser that parses the receiver one or more times."	^ self star setMin: 1! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:04'!plusGreedy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ (self starGreedy: aParser) setMin: 1! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:04'!plusLazy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ (self starLazy: aParser) setMin: 1! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/2/2011 10:02'!star	"Answer a new parser that parses the receiver zero or more times. This is a greedy and blind implementation that tries to consume as much input as possible and it does not consider what comes afterwards."	^ PPPossessiveRepeatingParser on: self! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/2/2011 10:01'!starGreedy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ PPGreedyRepeatingParser on: self limit: aParser! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/2/2011 10:01'!starLazy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ PPLazyRepeatingParser on: self limit: aParser! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 9/15/2010 09:34'!times: anInteger	"Answer a new parser that parses the receiver exactly anInteger times."		^ self min: anInteger max: anInteger! !!PPParser methodsFor: 'copying' stamp: 'lr 4/19/2010 10:33'!postCopy	super postCopy.	properties := properties copy! !!PPParser methodsFor: 'printing' stamp: 'lr 4/16/2010 16:36'!printNameOn: aStream	self name isNil		ifTrue: [ aStream print: self hash ]		ifFalse: [ aStream nextPutAll: self name ]! !!PPParser methodsFor: 'printing' stamp: 'lr 4/16/2010 16:36'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printNameOn: aStream.	aStream nextPut: $)! !!PPParser methodsFor: '*petitanalyzer-transforming' stamp: 'lr 4/13/2010 09:38'!replace: aParser with: anotherParser	"Replace the references of the receiver pointing to aParser with anotherParser."! !!PPParser methodsFor: '*petitanalyzer-transforming' stamp: 'lr 10/30/2010 11:54'!transform: aBlock	"Answer a copy of all parsers reachable from the receiver transformed using aBlock."	| mapping root |	mapping := IdentityDictionary new.	self allParsersDo: [ :each |		mapping			at: each			put: (aBlock value: each copy) ].	root := mapping at: self.	[	| changed |		changed := false.		root allParsersDo: [ :each |			each children do: [ :old |				mapping at: old ifPresent: [ :new |					each replace: old with: new.					changed := true ] ] ].		changed ] whileTrue.	^ root! !!PPParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/13/2009 14:11'!backgroundForDepth: anInteger	^ Color gray: 1.0 - (anInteger / 20.0)! !!PPParser methodsFor: '*petitgui-accessing' stamp: 'lr 9/12/2011 18:34'!displayColor	^ self isTerminal		ifTrue: [ Color r: 0.5 g: 0.0 b: 0.5 ]		ifFalse: [ Color blue ]! !!PPParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/6/2009 18:31'!displayName	^ self name isNil		ifFalse: [ self name asString ]		ifTrue: [ self class name asString ]! !!PPParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/9/2009 14:37'!example	^ String streamContents: [ :stream | self exampleOn: stream ] limitedTo: 1024! !!PPParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/9/2009 14:20'!exampleOn: aStream! !!PPParser methodsFor: '*petitgui' stamp: 'TudorGirba 11/25/2012 20:41'!gtInspectorParserInspectorIn: composite	<gtInspectorPresentationOrder: 30>	composite custom: (		PPParserInspector new 			title: 'Inspector';			startOn: self)! !!PPParser methodsFor: '*petitgui' stamp: 'TudorGirba 6/24/2013 23:44'!gtNamedTreeViewIn: composite	<gtInspectorPresentationOrder: 40>	composite tree		title: 'Named Tree';		children: [:n | n namedChildren ];		format: [:n| n name ifNil: [ n asString ] ];		shouldExpandToLevel: 3! !!PPParser methodsFor: '*petitgui' stamp: 'TudorGirba 6/24/2013 23:44'!gtTreeViewIn: composite	<gtInspectorPresentationOrder: 40>	composite tree			title: 'Tree';			children: [:n | n children ];			format: [:n| n name ifNil: [ n asString ] ifNotNil: [n name] ];			shouldExpandToLevel: 6! !!PPParser methodsFor: '*petitjava-operations' stamp: 'sback 9/2/2010 23:01'!javaToken	^ PPJavaTokenParser on: self! !!PPParser methodsFor: '*petitgui-morphic' stamp: 'lr 11/18/2009 10:56'!morphicProduction	^ self newRowMorph		layoutInset: 4;		addMorphBack: (self newRowMorph			layoutInset: 4;			addMorphBack: (StringMorph new				contents: self displayName;				emphasis: TextEmphasis bold emphasisCode;				yourself);			yourself);		addMorphBack: (self morphicShapeSeen: IdentitySet new depth: 0);		addMorphBack: (self newColumnMorph			addMorphBack: (self newSpacerMorph);			addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1)					makeForwardArrow;			yourself);		yourself! !!PPParser methodsFor: '*petitgui-morphic' stamp: 'lr 1/30/2013 19:35'!morphicShapeDefault	^ self newRowMorph		addMorphBack: (self newColumnMorph			addMorphBack: (self newSpacerMorph);			addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1)					makeForwardArrow;			yourself);		addMorphBack: (self newRowMorph			borderWidth: 1;			layoutInset: 3;			color: Color white;			addMorphBack: (StringMorph new				contents: self displayName;				color: self displayColor;				yourself);			yourself);		yourself! !!PPParser methodsFor: '*petitgui-morphic' stamp: 'lr 11/13/2009 13:24'!morphicShapeSeen: aSet depth: anInteger	^ self morphicShapeDefault! !!PPParser methodsFor: '*petitgui-morphic' stamp: 'lr 11/13/2009 13:43'!morphicShapeSeen: aSet depth: anInteger do: aBlock	" avoid recursion "	(aSet includes: self)		ifTrue: [ ^ self morphicShapeDefault ].	" display nice name when possible "	(anInteger > 0 and: [ self name notNil ]) 		ifTrue: [ ^ self morphicShapeDefault ].	" don't do it too deep "	(anInteger > 10)		ifTrue: [ ^ self morphicShapeDefault ].	aSet add: self. 	^ aBlock value: [ :parser |		parser 			morphicShapeSeen: aSet 			depth: anInteger + 1 ]! !!PPParser methodsFor: '*petitgui-mondrian' stamp: 'tg 8/25/2010 00:31'!namedParsers    | result |    result := OrderedCollection new.    self namedParsersDo: [ :parser | result addLast: parser ].    ^ result! !!PPParser methodsFor: '*petitgui-mondrian' stamp: 'tg 8/25/2010 00:32'!namedParsersDo: aBlock    self namedParsersDo: aBlock seen: IdentitySet new! !!PPParser methodsFor: '*petitgui-mondrian' stamp: 'TudorGirba 12/14/2011 12:40'!namedParsersDo: aBlock seen: aSet    self children do: [ :each |         (aSet includes: each)            ifFalse: [		        aSet add: each.		        each name isEmptyOrNil		            ifFalse: [ aBlock value: each ]		            ifTrue: [ each namedParsersDo: aBlock seen: aSet ] ] ]! !!PPParser methodsFor: '*petitgui-mondrian' stamp: 'TudorGirba 6/5/2013 23:01'!viewAllNamedParsers	| view |	view := ROMondrianViewBuilder new.	self viewAllNamedParsersOn: view.	^ view open setLabel: 'All named parsers'! !!PPParser methodsFor: '*petitgui-mondrian' stamp: 'JurajKubelka 5/30/2013 13:55'!viewAllNamedParsersOn: view	view shape rectangleWithoutBorder; withText: #displayName.	view nodes: (self allParsers select: [:each |  each name isEmptyOrNil not ]).	view edgesToAll: #namedParsers.	view horizontalDominanceTreeLayout layered! !!PPParser methodsFor: '*petitgui-mondrian' stamp: 'TudorGirba 12/6/2011 07:43'!viewAllNamedParsersWithSelection: aCollectionOfNames on: view	self viewAllNamedParsersWithSelection: aCollectionOfNames previewing: [ :each | each name ] on: view! !!PPParser methodsFor: '*petitgui-mondrian' stamp: 'TudorGirba 10/18/2012 09:38'!viewAllNamedParsersWithSelection: aCollectionOfNames previewing: aBlock on: view	view shape label 		color: [:each | (aCollectionOfNames includes: each name) ifFalse: [Color black] ifTrue: [Color red]];		text: [:each |each displayName].	view interaction popupText: aBlock.	view interaction item: 'Explore' action: #explore.	view nodes: (self allParsers select: [:each |  each name isEmptyOrNil not ]).	view edges: (self allParsers select: [:each |  each name isEmptyOrNil not ])from: #yourself toAll: #namedParsers.	view horizontalDominanceTreeLayout verticalGap: 10; layered! !!PPParser methodsFor: '*petitgui-morphic-creational' stamp: 'lr 11/17/2009 21:58'!newColumnMorph	^ AlignmentMorph newColumn		cellPositioning: #topLeft;		color: Color transparent;		listCentering: #topLeft;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		layoutInset: 0;		yourself! !!PPParser methodsFor: '*petitgui-morphic-creational' stamp: 'lr 11/17/2009 21:57'!newRowMorph	^ AlignmentMorph newRow		cellPositioning: #topLeft;		color: Color transparent;		listCentering: #topLeft;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		layoutInset: 0;		yourself! !!PPParser methodsFor: '*petitgui-morphic-creational' stamp: 'lr 11/17/2009 22:03'!newSpacerMorph	^ Morph new		color: Color transparent;		borderWidth: 0;		extent: 7 @ 7;		yourself! !!PPParser methodsFor: '*petitsmalltalk-operations' stamp: 'lr 6/29/2010 14:27'!smalltalkToken	^ PPSmalltalkTokenParser on: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPParser class	instanceVariableNames: ''!!PPParser class methodsFor: 'instance creation' stamp: 'lr 10/27/2008 11:17'!named: aString	^ self new name: aString! !!PPParser class methodsFor: 'instance creation' stamp: 'lr 4/18/2008 14:00'!new	^ self basicNew initialize! !!PPParser class methodsFor: '*GT-PetitParserDebugger' stamp: 'AndreiChis 8/13/2013 17:45'!productionSelectors	^ #()! !PPParser subclass: #PPPredicateParser	instanceVariableNames: 'predicate predicateMessage negated negatedMessage'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPPredicateParser commentStamp: '<historical>' prior: 0!An abstract parser that accepts if a given predicate holds.Instance Variables:	predicate	<BlockClosure>	The block testing for the predicate.	predicateMessage	<String>	The error message of the predicate.	negated	<BlockClosure>	The block testing for the negation of the predicate.	negatedMessage	<String>	The error message of the negated predicate.!!PPPredicateParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:36'!block	"Answer the predicate block of the receiver."		^ predicate! !!PPPredicateParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:36'!message	"Answer the failure message."		^ predicateMessage! !!PPPredicateParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 9/15/2010 11:56'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self block = aParser block and: [ self message = aParser message ] ]! !!PPPredicateParser methodsFor: 'printing' stamp: 'lr 5/2/2010 13:37'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: predicateMessage! !!PPPredicateParser methodsFor: '*petitgui-accessing' stamp: 'lr 5/2/2010 19:35'!displayName	^ predicateMessage! !!PPPredicateParser methodsFor: '*petitgui-accessing' stamp: 'lr 5/1/2010 17:05'!exampleOn: aStream	"Produce a random character that is valid. If there are characters in the alpha-numeric range prefer those over all others."	| valid normal |	valid := Character allCharacters		select: [ :char | self matches: (String with: char) ].	normal := valid		select: [ :char | char asInteger < 127 and: [ char isAlphaNumeric ] ].	aStream nextPut: (normal isEmpty		ifTrue: [ valid atRandom ]		ifFalse: [ normal atRandom ])! !PPPredicateParser subclass: #PPPredicateSequenceParser	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPPredicateSequenceParser commentStamp: '<historical>' prior: 0!A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.Instance Variables:	size	<Integer>	The number of elements to consume.!!PPPredicateSequenceParser methodsFor: 'initialization' stamp: 'lr 6/12/2010 09:13'!initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString.	size := anInteger ! !!PPPredicateSequenceParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 6/18/2010 14:09'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self size = aParser size ]! !!PPPredicateSequenceParser methodsFor: 'operators' stamp: 'lr 6/12/2010 09:14'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage		negated: predicate message: predicateMessage		size: size! !!PPPredicateSequenceParser methodsFor: 'parsing' stamp: 'lr 6/12/2010 09:25'!parseOn: aStream	| position result |	position := aStream position.	result := aStream next: size.	(result size = size and: [ predicate value: result ])		ifTrue: [ ^ result ].	aStream position: position.	^ PPFailure message: predicateMessage at: aStream position! !!PPPredicateSequenceParser methodsFor: 'accessing' stamp: 'lr 6/12/2010 08:58'!size	"Answer the sequence size of the receiver."	^ size! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPPredicateSequenceParser class	instanceVariableNames: ''!!PPPredicateSequenceParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:14'!on: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger 	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger! !!PPPredicateSequenceParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:14'!on: aBlock message: aString size: anInteger	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString size: anInteger ! !PPParser subclass: #PPPluggableParser	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPPluggableParser commentStamp: '<historical>' prior: 0!A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.Instance Variables:	block	<BlockClosure>	The pluggable one-argument block.!!PPPluggableParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:10'!block	"Answer the pluggable block."	^ block! !!PPPluggableParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 16:52'!initializeOn: aBlock	block := aBlock! !!PPPluggableParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 6/18/2010 14:09'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self block = aParser block ]! !!PPPluggableParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:54'!parseOn: aStream	| position result |	position := aStream position.	result := block value: aStream.	result isPetitFailure		ifTrue: [ aStream position: position ].	^ result! !!PPPluggableParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/13/2009 14:41'!displayName	^ String streamContents: [ :stream | block decompile shortPrintOn: stream ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPPluggableParser class	instanceVariableNames: ''!!PPPluggableParser class methodsFor: 'instance creation' stamp: 'lr 5/2/2010 16:52'!on: aBlock	^ self new initializeOn: aBlock! !PPParser subclass: #PPEpsilonParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPEpsilonParser commentStamp: 'lr 5/15/2008 15:09' prior: 0!A parser that consumes nothing and always succeeds.!!PPEpsilonParser methodsFor: '*petitanalyzer-testing' stamp: 'lr 10/21/2009 12:11'!isNullable	^ true! !!PPEpsilonParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:49'!parseOn: aStream	^ nil! !!PPEpsilonParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/6/2009 18:42'!displayName	^ 'epsilon'! !!PPEpsilonParser methodsFor: '*petitgui-morphic' stamp: 'lr 11/18/2009 11:15'!morphicShapeSeen: aSet depth: anInteger	^ self morphicShapeSeen: aSet depth: anInteger do: [ :cc |		self newRowMorph			addMorphBack: (self newColumnMorph				addMorphBack: (self newSpacerMorph height: 10);				addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1);				yourself);			yourself ]! !PPParser subclass: #PPDelegateParser	instanceVariableNames: 'parser'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPDelegateParser commentStamp: '<historical>' prior: 0!A parser that delegates to another parser.Instance Variables:	parser	<PPParser>	The parser to delegate to.!!PPDelegateParser methodsFor: 'accessing' stamp: 'lr 10/21/2009 16:37'!children	^ Array with: parser! !!PPDelegateParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:47'!parseOn: aStream	^ parser parseOn: aStream! !!PPDelegateParser methodsFor: '*petitanalyzer-transforming' stamp: 'lr 4/13/2010 09:39'!replace: aParser with: anotherParser	super replace: aParser with: anotherParser.	parser == aParser ifTrue: [ parser := anotherParser ]! !!PPDelegateParser methodsFor: 'initialization' stamp: 'lr 4/20/2008 16:23'!setParser: aParser	parser := aParser! !!PPDelegateParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/13/2009 14:20'!displayDescription	^ nil! !!PPDelegateParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/9/2009 14:27'!exampleOn: aStream	parser exampleOn: aStream! !!PPDelegateParser methodsFor: '*petitgui-morphic' stamp: 'lr 11/18/2009 11:21'!morphicShapeSeen: aSet depth: anInteger	^ self morphicShapeSeen: aSet depth: anInteger do: [ :cc |		self displayDescription isNil			ifTrue: [ cc value: parser ]			ifFalse: [				self newRowMorph					addMorphBack: (self newColumnMorph						addMorphBack: (self newSpacerMorph height: 10);						addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1);						yourself);					addMorphBack: (self newRowMorph						color: (self backgroundForDepth: anInteger);						addMorphBack: (self newColumnMorph							addMorphBack: (cc value: parser);							addMorphBack: (self newRowMorph								hResizing: #spaceFill;								addMorphBack: (self newSpacerMorph									width: 20;									yourself);								addMorphBack: (self newColumnMorph									hResizing: #spaceFill;									listCentering: #center;									addMorphBack: (self newSpacerMorph);									addMorphBack: (StringMorph new										contents: self displayDescription;										yourself);									yourself);								yourself);							yourself);								addMorphBack: (self newColumnMorph							addMorphBack: (self newSpacerMorph height: 10);							addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1);							yourself);						yourself);					yourself ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPDelegateParser class	instanceVariableNames: ''!!PPDelegateParser class methodsFor: 'instance creation' stamp: 'lr 4/20/2008 16:22'!on: aParser	^ self new setParser: aParser! !PPDelegateParser subclass: #PPAndParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPAndParser commentStamp: 'TudorGirba 2/27/2011 22:22' prior: 0!The and-predicate, a parser that succeeds whenever its delegate does, but does not consume the input stream [Parr 1994, 1995].!!PPAndParser methodsFor: 'operators' stamp: 'lr 5/1/2010 16:16'!and	^ self! !!PPAndParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:10'!parseOn: aStream	| element position |	position := aStream position.	element := parser parseOn: aStream.	aStream position: position.	^ element! !!PPAndParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/13/2009 14:17'!displayDescription	^ 'and'! !!PPAndParser methodsFor: '*petitgui-accessing' stamp: 'lr 5/1/2010 16:16'!exampleOn: aStream! !PPDelegateParser subclass: #PPTrimmingParser	instanceVariableNames: 'trimmer'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPTrimmingParser commentStamp: 'lr 4/6/2010 19:27' prior: 0!A parser that silently consumes spaces before and after the delegate parser.!!PPTrimmingParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:11'!parseOn: aStream	| position element |	position := aStream position.	[ (trimmer parseOn: aStream) isPetitFailure ]		whileFalse.	element := parser parseOn: aStream.	element isPetitFailure ifTrue: [		aStream position: position.		^ element ].	[ (trimmer parseOn: aStream) isPetitFailure ]		whileFalse.	^ element! !!PPTrimmingParser methodsFor: 'initialization' stamp: 'lr 7/31/2010 12:00'!setTrimmer: aParser	trimmer := aParser! !!PPTrimmingParser methodsFor: '*petitgui-accessing' stamp: 'lr 4/14/2010 20:48'!exampleOn: aStream	super exampleOn: aStream.	aStream nextPut: Character space! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPTrimmingParser class	instanceVariableNames: ''!!PPTrimmingParser class methodsFor: 'instance creation' stamp: 'lr 7/31/2010 12:01'!on: aParser trimmer: aTrimParser	^ self new		setParser: aParser;		setTrimmer: aTrimParser;		yourself! !PPDelegateParser subclass: #PPFlattenParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPFlattenParser commentStamp: 'lr 11/22/2009 13:09' prior: 0!A parser that answers a flat copy of the range my delegate parses.!!PPFlattenParser methodsFor: 'private' stamp: 'lr 2/25/2013 23:31'!on: aCollection start: aStartInteger stop: aStopInteger value: anObject	^ aCollection copyFrom: aStartInteger to: aStopInteger! !!PPFlattenParser methodsFor: 'parsing' stamp: 'lr 2/25/2013 23:30'!parseOn: aStream	| start element |	start := aStream position.	element := parser parseOn: aStream.	element isPetitFailure ifTrue: [ ^ element ].	^ self on: aStream collection start: start + 1 stop: aStream position value: element! !PPDelegateParser subclass: #PPMemoizedParser	instanceVariableNames: 'stream buffer'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPMemoizedParser commentStamp: '<historical>' prior: 0!A memoized parser, for refraining redundant computations.Instance Variables:	stream	<PositionableStream>	The stream of the associated memento objects.	buffer	<Array of: PPMemento>	The buffer of memento objects.!!PPMemoizedParser methodsFor: 'operators' stamp: 'lr 4/2/2009 19:48'!memoized	"Ther is no point in memoizing more than once."	^ self! !!PPMemoizedParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:11'!parseOn: aStream	| memento |	stream == aStream		ifFalse: [ self reset: aStream ].	memento := (buffer at: stream position + 1)		ifNil: [ buffer at: stream position + 1 put: PPMemento new ].	memento position isNil		ifTrue: [			memento result: (stream size - stream position + 2 < memento count				ifTrue: [ PPFailure message: 'overflow' at: stream position ]				ifFalse: [ memento increment. parser parseOn: stream ]).			memento position: stream position ]		ifFalse: [ stream position: memento position ].	^ memento result! !!PPMemoizedParser methodsFor: 'private' stamp: 'lr 4/2/2009 19:22'!reset: aStream	stream := aStream.	buffer := Array new: aStream size + 1! !PPDelegateParser subclass: #PPActionParser	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPActionParser commentStamp: '<historical>' prior: 0!A parser that performs an action block with the successful parse result of the delegate.Instance Variables:	block	<BlockClosure>	The action block to be executed.!!PPActionParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:10'!block	"Answer the action block of the receiver."	^ block! !!PPActionParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 5/7/2011 15:08'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self block = aParser block ]! !!PPActionParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:10'!parseOn: aStream	| element |	^ (element := parser parseOn: aStream) isPetitFailure		ifFalse: [ block value: element ]		ifTrue: [ element ]! !!PPActionParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 16:58'!setBlock: aBlock	block := aBlock! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPActionParser class	instanceVariableNames: ''!!PPActionParser class methodsFor: 'instance creation' stamp: 'lr 5/2/2010 16:58'!on: aParser block: aBlock	^ (self on: aParser) setBlock: aBlock! !PPActionParser subclass: #PPWrappingParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPWrappingParser commentStamp: '<historical>' prior: 0!A parser that performs an action block upon activation with the stream and a continuation block.!!PPWrappingParser methodsFor: 'parsing' stamp: 'lr 5/12/2010 20:19'!parseOn: aStream	^ block value: aStream value: [ parser parseOn: aStream ]! !PPParser subclass: #PPFailingParser	instanceVariableNames: 'message'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPFailingParser commentStamp: '<historical>' prior: 0!A parser that consumes nothing and always fails.Instance Variables:	message <String>	The failure message.!!PPFailingParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 4/30/2010 12:01'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self message = aParser message ]! !!PPFailingParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:10'!message	"Answer the error message of the receiving parser."	^ message! !!PPFailingParser methodsFor: 'parsing' stamp: 'lr 5/5/2010 13:57'!parseOn: aStream	^ PPFailure message: message at: aStream position! !!PPFailingParser methodsFor: 'printing' stamp: 'lr 4/16/2010 21:27'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: message! !!PPFailingParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 19:16'!setMessage: aString	message := aString! !!PPFailingParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/13/2009 14:16'!displayColor	^ Color red! !!PPFailingParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/6/2009 18:43'!displayName	^ message! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPFailingParser class	instanceVariableNames: ''!!PPFailingParser class methodsFor: 'instance creation' stamp: 'lr 5/2/2010 19:16'!message: aString	^ self new setMessage: aString! !PPParser subclass: #PPLiteralParser	instanceVariableNames: 'literal message'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLiteralParser commentStamp: '<historical>' prior: 0!Abstract literal parser that parses some kind of literal type (to be specified by subclasses).Instance Variables:	literal	<Object>	The literal object to be parsed.	message	<String>	The error message to be generated.!!PPLiteralParser methodsFor: 'operators' stamp: 'lr 6/1/2010 22:24'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		self subclassResponsibility! !!PPLiteralParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 13:25'!initializeOn: anObject message: aString	literal := anObject.	message := aString! !!PPLiteralParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:26'!literal	"Answer the parsed literal."	^ literal! !!PPLiteralParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:26'!message	"Answer the failure message."		^ message! !!PPLiteralParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 9/15/2010 12:08'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self literal = aParser literal and: [ self message = aParser message ] ]! !!PPLiteralParser methodsFor: 'printing' stamp: 'lr 4/16/2010 16:38'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: literal! !!PPLiteralParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/13/2009 14:19'!displayName	^ literal printString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPLiteralParser class	instanceVariableNames: ''!!PPLiteralParser class methodsFor: 'instance creation' stamp: 'lr 1/7/2010 15:30'!on: anObject	^ self on: anObject message: anObject printString , ' expected'! !!PPLiteralParser class methodsFor: 'instance creation' stamp: 'lr 1/7/2010 15:29'!on: anObject message: aString	^ self new initializeOn: anObject message: aString! !PPLiteralParser subclass: #PPLiteralSequenceParser	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLiteralSequenceParser commentStamp: 'lr 12/4/2009 18:39' prior: 0!A parser accepts a sequence of literal objects, such as a String. This is an optimization to avoid having to compose longer sequences from PPSequenceParser.!!PPLiteralSequenceParser methodsFor: 'operators' stamp: 'lr 8/18/2010 20:16'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateSequenceParser on: [ :value | literal sameAs: value ] message: message size: size! !!PPLiteralSequenceParser methodsFor: 'initialization' stamp: 'lr 6/1/2010 22:21'!initializeOn: anObject message: aString	super initializeOn: anObject message: aString.	size := literal size! !!PPLiteralSequenceParser methodsFor: 'parsing' stamp: 'lr 10/30/2010 11:48'!parseOn: aStream	| position result |	position := aStream position.	result := aStream next: size.	literal = result ifTrue: [ ^ result ].	aStream position: position.	^ PPFailure message: message at: aStream position! !!PPLiteralSequenceParser methodsFor: 'accessing' stamp: 'lr 9/15/2010 11:16'!size	"Answer the sequence size of the receiver."	^ size! !!PPLiteralSequenceParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/9/2009 14:25'!exampleOn: aStream	aStream nextPutAll: literal! !PPDelegateParser subclass: #PPEndOfInputParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPEndOfInputParser commentStamp: 'lr 4/18/2008 13:46' prior: 0!A parser that succeeds only at the end of the input stream.!!PPEndOfInputParser methodsFor: 'operators' stamp: 'lr 12/7/2009 08:53'!end	^ self! !!PPEndOfInputParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:10'!parseOn: aStream	| position result |	position := aStream position.	result := parser parseOn: aStream.	(result isPetitFailure or: [ aStream atEnd ])		ifTrue: [ ^ result ].	result := PPFailure		message: 'end of input expected'		at: aStream position.	aStream position: position.	^ result! !!PPEndOfInputParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/13/2009 14:18'!displayDescription	^ 'end of input'! !PPPredicateParser subclass: #PPPredicateObjectParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPPredicateObjectParser commentStamp: '<historical>' prior: 0!A parser that accepts if a given predicate on one element of the input sequence holds.!!PPPredicateObjectParser methodsFor: 'initialization' stamp: 'lr 6/12/2010 09:12'!initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString! !!PPPredicateObjectParser methodsFor: 'operators' stamp: 'lr 6/12/2010 09:12'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage 		negated: predicate message: predicateMessage! !!PPPredicateObjectParser methodsFor: 'parsing' stamp: 'lr 9/30/2010 11:05'!parseOn: aStream	^ (aStream atEnd not and: [ predicate value: aStream uncheckedPeek ])		ifFalse: [ PPFailure message: predicateMessage at: aStream position ]		ifTrue: [ aStream next ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPPredicateObjectParser class	instanceVariableNames: ''!!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 6/12/2010 09:10'!any	^ self		on: [ :each | true ] message: 'input expected'		negated: [ :each | false ] message: 'no input expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 4/1/2011 20:05'!anyExceptAnyOf: aCollection	^ self		on: [ :each | (aCollection includes: each) not ] message: 'any except ' , aCollection printString , ' expected'		negated: [ :each | aCollection includes: each ] message: aCollection printString ,  ' not expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 4/1/2011 20:05'!anyOf: aCollection	^ self		on: [ :each | aCollection includes: each ] message: 'any of ' , aCollection printString , ' expected'		negated: [ :each | (aCollection includes: each) not ] message: 'none of ' , aCollection printString ,  'expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 6/12/2010 09:10'!between: min and: max	^ self		on: [ :each | each >= min and: [ each <= max ] ] message: min printString , '..' , max printString , ' expected'		negated: [ :each | each < min or: [ each > max ] ] message: min printString , '..' , max printString , ' not expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 8/25/2010 10:57'!expect: anObject	^ self expect: anObject message: anObject printString , ' expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 8/25/2010 10:57'!expect: anObject message: aString	^ self 		on: [ :each | each = anObject ] message: aString		negated: [ :each | each ~= anObject ] message: 'no ' , aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:02'!blank	^ self chars: (String with: Character space with: Character tab) message: 'blank expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:02'!char: aCharacter	^ self expect: aCharacter message: (String with: $" with: aCharacter with: $") , ' expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 10:57'!char: aCharacter message: aString	^ self expect: aCharacter message: aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!chars: aCollection message: aString	^ self on: (PPCharSetPredicate on: [ :char | aCollection includes: char ]) message: aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:02'!cr	^ self char: Character cr message: 'carriage return expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!digit	^ self on: (PPCharSetPredicate on: [ :char | char isDigit ]) message: 'digit expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!hex	^ self 		on: (PPCharSetPredicate on: [ :char | 			(char between: $0 and: $9) 				or: [ (char between: $a and: $f) 				or: [ (char between: $A and: $F) ] ] ])		message: 'hex digit expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:05'!letter	^ self on: (PPCharSetPredicate on: [ :char | char isLetter ]) message: 'letter expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 6/12/2010 09:10'!lf	^ self char: Character lf! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!lowercase	^ self on: (PPCharSetPredicate on: [ :char | char isLowercase ]) message: 'lowercase letter expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:04'!newline	^ self chars: (String with: Character cr with: Character lf) message: 'newline expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:04'!punctuation	^ self chars: '.,"''?!!;:#$%&()*+-/<>=@[]\^_{}|~' message: 'punctuation expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!space	^ self on: (PPCharSetPredicate on: [ :char | char isSeparator ]) message: 'separator expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:04'!tab	^ self char: Character tab message: 'tab expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!uppercase	^ self on: (PPCharSetPredicate on: [ :char | char isUppercase ]) message: 'uppercase letter expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!word	^ self on: (PPCharSetPredicate on: [ :char | char isAlphaNumeric ]) message: 'letter or digit expected'! !!PPPredicateObjectParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:10'!on: aBlock message: aString	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString! !!PPPredicateObjectParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:10'!on: aBlock message: aString negated: aNegatedBlock message: aNegatedString	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString! !PPFlattenParser subclass: #PPTokenParser	instanceVariableNames: 'tokenClass'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPTokenParser commentStamp: 'lr 2/25/2013 23:31' prior: 0!A parser that answers a token with the value of my delegate parses.Instance Variables:	tokenClass	<PPToken class>	The token sub-class to be used.!!PPTokenParser methodsFor: 'private' stamp: 'lr 4/6/2010 19:18'!defaultTokenClass	^ PPToken! !!PPTokenParser methodsFor: 'private' stamp: 'lr 2/25/2013 23:32'!on: aCollection start: aStartInteger stop: aStopInteger value: anObject	^ self tokenClass on: aCollection start: aStartInteger stop: aStopInteger value: anObject! !!PPTokenParser methodsFor: 'initialization' stamp: 'lr 4/6/2010 19:19'!initialize	tokenClass := self defaultTokenClass	! !!PPTokenParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 6/18/2010 14:09'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self tokenClass = aParser tokenClass ]! !!PPTokenParser methodsFor: 'accessing' stamp: 'lr 4/6/2010 19:23'!tokenClass	^ tokenClass! !!PPTokenParser methodsFor: 'accessing' stamp: 'lr 4/6/2010 19:24'!tokenClass: aTokenClass	tokenClass := aTokenClass! !PPDelegateParser subclass: #PPRepeatingParser	instanceVariableNames: 'min max'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPRepeatingParser commentStamp: 'lr 4/3/2011 14:45' prior: 0!An abstract parser that repeatedly parses between 'min' and 'max' instances of its delegate. The default configuration parses an infinite number of elements, as 'min' is set to 0 and 'max' to infinity (SmallInteger maxVal).Instance Variables:	min	<Integer>	The minimum number of repetitions.	max	<Integer>	The maximum number of repetitions.!!PPRepeatingParser methodsFor: '*petitanalyzer-private' stamp: 'JanKurs 5/31/2013 11:51'!followSets: aFollowDictionary firstSets: aFirstDictionary into: aSet	| firstSet |	super followSets: aFollowDictionary firstSets:  aFirstDictionary into: aSet.		firstSet := aFirstDictionary at: self.	self children do: [:p | (aFollowDictionary at: p) addAll: (firstSet reject: [:each | each isNullable]) ]! !!PPRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/1/2011 21:06'!initialize	super initialize.	self setMin: 0; setMax: SmallInteger maxVal! !!PPRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/1/2011 21:00'!setMax: anInteger	max := anInteger! !!PPRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/1/2011 21:01'!setMin: anInteger	min := anInteger! !!PPRepeatingParser methodsFor: '*petitanalyzer-testing' stamp: 'lr 10/21/2009 12:13'!isNullable	^ min = 0! !!PPRepeatingParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 6/18/2010 14:09'!match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self min = aParser min and: [ self max = aParser max ] ]! !!PPRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:08'!max	"Answer the maximum number of repetitions."	^ max! !!PPRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:08'!min	"Answer the minimum number of repetitions."		^ min! !!PPRepeatingParser methodsFor: 'printing' stamp: 'lr 6/3/2010 14:00'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ['; print: min; nextPutAll: ', '; nextPutAll: (max = SmallInteger maxVal		ifTrue: [ '*' ] ifFalse: [ max printString ]); nextPut: $]! !!PPRepeatingParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/13/2009 14:18'!displayDescription	^ String streamContents: [ :stream |		min = 0 			ifFalse: [ stream print: min; nextPutAll: '..' ].		max = SmallInteger maxVal			ifTrue: [ stream nextPut: $* ]			ifFalse: [ stream print: max ] ]! !!PPRepeatingParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/11/2009 20:57'!exampleOn: aStream	"Perform the minimal repeatitions required, and a random amount of more if possible and if not that much output has been produced yet."		min timesRepeat: [ 		super exampleOn: aStream ].	(max - min min: 5) atRandom timesRepeat: [		aStream position > 512			ifTrue: [ ^ self ].		super exampleOn: aStream ]! !PPRepeatingParser subclass: #PPPossessiveRepeatingParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPPossessiveRepeatingParser commentStamp: 'lr 4/3/2011 14:35' prior: 0!The default repeating parser with standard PEG semantics (i.e. possessive, blind, eager).!!PPPossessiveRepeatingParser methodsFor: 'parsing' stamp: 'lr 4/2/2011 09:52'!parseOn: aStream	| start element elements |	start := aStream position.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [		(element := parser parseOn: aStream) isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements addLast: element ].	[ elements size < max ] whileTrue: [	 	(element := parser parseOn: aStream) isPetitFailure			ifTrue: [ ^ elements asArray ].		elements addLast: element ].	^ elements asArray! !PPRepeatingParser subclass: #PPLimitedRepeatingParser	instanceVariableNames: 'limit'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLimitedRepeatingParser commentStamp: 'lr 4/3/2011 14:37' prior: 0!An abstract parser that repeatedly parses between 'min' and 'max' instances of my delegate and that requires the input to be completed with a specified parser 'limit'. Subclasses provide repeating behavior as typically seen in regular expression implementations (non-blind).Instance Variables:	limit	<PPParser>	The parser to complete the input with.!!PPLimitedRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/4/2011 18:46'!children	^ Array with: parser with: limit! !!PPLimitedRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/2/2011 10:00'!limit	"Answer the parser that limits (or ends) this repetition."		^ limit! !!PPLimitedRepeatingParser methodsFor: 'private' stamp: 'lr 4/2/2011 10:10'!matchesLimitOn: aStream	| element position |	position := aStream position.	element := limit parseOn: aStream.	aStream position: position.	^ element isPetitFailure not! !!PPLimitedRepeatingParser methodsFor: '*petitanalyzer-transforming' stamp: 'lr 4/4/2011 18:46'!replace: aParser with: anotherParser	super replace: aParser with: anotherParser.	limit == aParser ifTrue: [ limit := anotherParser ]! !!PPLimitedRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/2/2011 10:00'!setLimit: aParser	limit := aParser! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPLimitedRepeatingParser class	instanceVariableNames: ''!!PPLimitedRepeatingParser class methodsFor: 'instance creation' stamp: 'lr 4/3/2011 14:58'!on: aParser limit: aLimitParser	^ (self on: aParser) setLimit: aLimitParser! !PPLimitedRepeatingParser subclass: #PPLazyRepeatingParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLazyRepeatingParser commentStamp: 'lr 4/3/2011 15:08' prior: 0!A lazy repeating parser, commonly seen in regular expression implementations. It limits its consumption to meet the 'limit' condition as early as possible.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (limit and ==> [ :each | OrderedCollection new ])		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])).	^ parser ==> [ :rest | rest asArray ]!!PPLazyRepeatingParser methodsFor: 'parsing' stamp: 'lr 4/2/2011 10:14'!parseOn: aStream	| start element elements |	start := aStream position.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [		(element := parser parseOn: aStream) isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements addLast: element ].	[ self matchesLimitOn: aStream ] whileFalse: [		elements size < max ifFalse: [			aStream position: start.			^ PPFailure message: 'overflow' at: start ].		element := parser parseOn: aStream.		element isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements addLast: element ].	^ elements asArray! !PPLimitedRepeatingParser subclass: #PPGreedyRepeatingParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPGreedyRepeatingParser commentStamp: 'lr 4/3/2011 15:08' prior: 0!A greedy repeating parser, commonly seen in regular expression implementations. It aggressively consumes as much input as possible and then backtracks to meet the 'limit' condition.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])		with: (limit and ==> [ :each | OrderedCollection new ])).	^ parser ==> [ :rest | rest asArray ]!!PPGreedyRepeatingParser methodsFor: 'parsing' stamp: 'lr 4/2/2011 15:54'!parseOn: aStream	| start element elements positions |	start := aStream position.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [ 		(element := parser parseOn: aStream) isPetitFailure ifTrue: [ 			aStream position: start.			^ element ].		elements addLast: element ].	positions := OrderedCollection with: aStream position.	[ elements size < max and: [ (element := parser parseOn: aStream) isPetitFailure not ] ] whileTrue: [		elements addLast: element.		positions addLast: aStream position ].	[ positions isEmpty ] whileFalse: [		aStream position: positions last.		element := limit parseOn: aStream.		element isPetitFailure ifFalse: [			aStream position: positions last.			^ elements asArray ].		elements isEmpty ifTrue: [			aStream position: start.			^ element ].		elements removeLast.		positions removeLast ].	aStream position: start.	^ PPFailure message: 'overflow' at: start! !PPLiteralParser subclass: #PPLiteralObjectParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPLiteralObjectParser commentStamp: '<historical>' prior: 0!A parser that accepts a single literal object, such as a character. This is the same as the predicate parser 'PPPredicateParser expect: literal' but slightly more efficient.!!PPLiteralObjectParser methodsFor: 'operators' stamp: 'lr 8/18/2010 20:16'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateObjectParser on: [ :value | literal sameAs: value ] message: message! !!PPLiteralObjectParser methodsFor: 'operators' stamp: 'lr 4/28/2011 20:02'!negate	^ (PPPredicateObjectParser expect: literal message: message) negate! !!PPLiteralObjectParser methodsFor: 'parsing' stamp: 'lr 10/30/2010 11:48'!parseOn: aStream	^ (aStream atEnd not and: [ literal = aStream uncheckedPeek ])		ifFalse: [ PPFailure message: message at: aStream position ]		ifTrue: [ aStream next ]! !!PPLiteralObjectParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/9/2009 14:25'!exampleOn: aStream	aStream nextPut: literal! !PPParser subclass: #PPListParser	instanceVariableNames: 'parsers'	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPListParser commentStamp: '<historical>' prior: 0!Abstract parser that parses a list of things in some way (to be specified by the subclasses).Instance Variables:	parsers	<SequenceableCollection of: PPParser>	A sequence of other parsers to delegate to.!!PPListParser methodsFor: 'accessing' stamp: 'lr 10/21/2009 16:37'!children	^ parsers! !!PPListParser methodsFor: '*petitanalyzer-matching' stamp: 'lr 4/30/2010 08:15'!copyInContext: aDictionary seen: aSeenDictionary	| copy copies |	aSeenDictionary at: self ifPresent: [ :value | ^ value ].	copy := aSeenDictionary at: self put: self copy.	copies := OrderedCollection new.	parsers do: [ :each |		| result |		result := each 			copyInContext: aDictionary			seen: aSeenDictionary.		result isCollection			ifTrue: [ copies addAll: result ]			ifFalse: [ copies add: result ] ].	^ copy		setParsers: copies;		yourself! !!PPListParser methodsFor: 'copying' stamp: 'lr 9/17/2008 22:36'!copyWith: aParser	^ self species withAll: (parsers copyWith: aParser)! !!PPListParser methodsFor: 'copying' stamp: 'lr 5/22/2010 10:26'!postCopy	super postCopy.	parsers := parsers copy! !!PPListParser methodsFor: 'initialization' stamp: 'lr 4/29/2010 10:12'!initialize	super initialize.	self setParsers: #()! !!PPListParser methodsFor: 'initialization' stamp: 'lr 4/29/2010 10:12'!setParsers: aCollection	parsers := aCollection asArray! !!PPListParser methodsFor: '*petitanalyzer-transforming' stamp: 'lr 5/22/2010 10:24'!replace: aParser with: anotherParser	super replace: aParser with: anotherParser.	parsers keysAndValuesDo: [ :index :parser |		parser == aParser			ifTrue: [ parsers at: index put: anotherParser ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPListParser class	instanceVariableNames: ''!!PPListParser class methodsFor: 'instance creation' stamp: 'lr 5/3/2010 20:26'!with: aParser	^ self withAll: (Array with: aParser)! !!PPListParser class methodsFor: 'instance creation' stamp: 'lr 9/23/2008 18:32'!with: aFirstParser with: aSecondParser	^ self withAll: (Array with: aFirstParser with: aSecondParser)! !!PPListParser class methodsFor: 'instance creation' stamp: 'lr 4/29/2010 10:12'!withAll: aCollection	^ self basicNew setParsers: aCollection! !PPListParser subclass: #PPSequenceParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPSequenceParser commentStamp: 'lr 4/18/2008 15:34' prior: 0!A parser that parses a sequence of parsers.!!PPSequenceParser methodsFor: 'operators' stamp: 'lr 9/17/2008 00:17'!, aRule	^ self copyWith: aRule! !!PPSequenceParser methodsFor: '*petitanalyzer-private' stamp: 'lr 12/9/2010 10:37'!cycleSet: aDictionary	| firstSet |	1 to: parsers size do: [ :index |		firstSet := aDictionary at: (parsers at: index).		(firstSet anySatisfy: [ :each | each isNullable ])			ifFalse: [ ^ parsers copyFrom: 1 to: index ] ].	^ parsers! !!PPSequenceParser methodsFor: '*petitanalyzer-private' stamp: 'lr 9/16/2010 17:56'!firstSets: aFirstDictionary into: aSet	| nullable |	parsers do: [ :parser |		nullable := false.		(aFirstDictionary at: parser) do: [ :each |			each isNullable				ifTrue: [ nullable := true ]				ifFalse: [ aSet add: each ] ].		nullable			ifFalse: [ ^ self ] ].	aSet add: PPSentinel instance! !!PPSequenceParser methodsFor: '*petitanalyzer-private' stamp: 'lr 8/14/2010 13:51'!followSets: aFollowDictionary firstSets: aFirstDictionary into: aSet	parsers keysAndValuesDo: [ :index :parser |		| followSet firstSet |		followSet := aFollowDictionary at: parser.		index = parsers size			ifTrue: [ followSet addAll: aSet ]			ifFalse: [				(self class withAll: (parsers 					copyFrom: index + 1 to: parsers size))						firstSets: aFirstDictionary						into: (firstSet := IdentitySet new).				(firstSet anySatisfy: [ :each | each isNullable ])					ifTrue: [ followSet addAll: aSet ].				followSet addAll: (firstSet 					reject: [ :each | each isNullable ]) ] ]! !!PPSequenceParser methodsFor: 'operators-mapping' stamp: 'lr 5/6/2011 20:27'!map: aBlock	^ aBlock numArgs = self children size		ifTrue: [ self ==> [ :nodes | aBlock valueWithArguments: nodes ] ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]! !!PPSequenceParser methodsFor: 'operators-mapping' stamp: 'lr 1/8/2010 12:01'!permutation: anArrayOfIntegers	"Answer a permutation of the receivers sequence."		anArrayOfIntegers do: [ :index |		(index isInteger and: [ index between: 1 and: parsers size ])			ifFalse: [ self error: 'Invalid permutation index: ' , index printString ] ].	^ self ==> [ :nodes | anArrayOfIntegers collect: [ :index | nodes at: index ] ]! !!PPSequenceParser methodsFor: 'parsing' stamp: 'lr 5/6/2010 10:47'!parseOn: aStream	"This is optimized code that avoids unnecessary block activations, do not change."		| start elements element |	start := aStream position.	elements := Array new: parsers size.	1 to: parsers size do: [ :index |		element := (parsers at: index) 			parseOn: aStream.		element isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements at: index put: element ].	^ elements! !!PPSequenceParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/9/2009 14:24'!exampleOn: aStream	parsers do: [ :each | each exampleOn: aStream ]! !!PPSequenceParser methodsFor: '*petitgui-morphic' stamp: 'lr 11/17/2009 21:54'!morphicShapeSeen: aSet depth: anInteger	^ self morphicShapeSeen: aSet depth: anInteger do: [ :cc |		self children			inject: self newRowMorph			into: [ :result :each | 				result 					addMorphBack: (cc value: each);					yourself ] ]! !PPListParser subclass: #PPChoiceParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPChoiceParser commentStamp: 'lr 4/18/2008 15:35' prior: 0!A parser that uses the first parser that succeeds.!!PPChoiceParser methodsFor: 'operators' stamp: 'lr 9/17/2008 00:16'!/ aRule 	^ self copyWith: aRule! !!PPChoiceParser methodsFor: 'parsing' stamp: 'lr 5/22/2010 11:48'!parseOn: aStream	"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."	| element |	1 to: parsers size do: [ :index |		element := (parsers at: index)			parseOn: aStream.		element isPetitFailure			ifFalse: [ ^ element ] ].	^ element! !!PPChoiceParser methodsFor: '*petitgui-morphic' stamp: 'lr 5/2/2010 20:15'!exampleOn: aStream	"If there is already a lot written, try to pick an empty possiblity."		aStream position > 512 ifTrue: [		(parsers anySatisfy: [ :each | each isNullable ])			ifTrue: [ ^ self ] ].	parsers atRandom exampleOn: aStream! !!PPChoiceParser methodsFor: '*petitgui-morphic' stamp: 'lr 11/18/2009 11:14'!morphicShapeSeen: aSet depth: anInteger	^ self morphicShapeSeen: aSet depth: anInteger do: [ :cc |		| morph |		morph := self newColumnMorph 			cellInset: 5;			yourself.		self children do: [ :each | 			morph addMorphBack: (self newRowMorph				hResizing: #spaceFill;				addMorphBack: (cc value: each);				addMorphBack: (self newColumnMorph					hResizing: #spaceFill;					addMorphBack: (self newSpacerMorph height: 10);					addMorphBack: ((LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1)						hResizing: #spaceFill;						minWidth: 20;						yourself);					yourself);				yourself) ].		morph fullBounds.		self newRowMorph			addMorphBack: (self newColumnMorph				addMorphBack: (self newSpacerMorph height: 10);				addMorphBack: (LineMorph from: 0 @ 0 to: 20 @ 0 color: Color black width: 1);				yourself);			addMorphBack: (self newColumnMorph				addMorphBack: (self newSpacerMorph width: 1; height: 10);				addMorphBack: (LineMorph from: 0 @ 0 to: 0 @ (morph height - 23) color: Color black width: 1);				yourself);			addMorphBack: morph;			addMorphBack: (self newColumnMorph				addMorphBack: (self newSpacerMorph width: 1; height: 10);				addMorphBack: (LineMorph from: 0 @ (morph height - 23) to: 0 @ 0 color: Color black width: 1)					makeForwardArrow;					width: 1;				yourself);			yourself ]! !PPDelegateParser subclass: #PPOptionalParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPOptionalParser commentStamp: 'lr 4/3/2011 14:46' prior: 0!A parser that optionally parsers its delegate, or answers nil.!!PPOptionalParser methodsFor: '*petitanalyzer-testing' stamp: 'lr 9/1/2010 22:10'!isNullable	^ true! !!PPOptionalParser methodsFor: 'parsing' stamp: 'lr 8/14/2011 11:47'!parseOn: aStream	| element |	element := parser parseOn: aStream.	^ element isPetitFailure ifFalse: [ element ]! !PPDelegateParser subclass: #PPNotParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PetitParser-Parsers'!!PPNotParser commentStamp: '<historical>' prior: 0!The not-predicate, a parser that succeeds whenever its delegate does not, but consumes no input [Parr 1994, 1995].!!PPNotParser methodsFor: '*petitanalyzer-private' stamp: 'JanKurs 5/31/2013 11:50'!firstSets: aFirstDictionary into: aSet	! !!PPNotParser methodsFor: '*petitanalyzer-testing' stamp: 'JanKurs 5/31/2013 11:50'!isFirstSetTerminal	^ true! !!PPNotParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:11'!parseOn: aStream	| element position |	position := aStream position.	element := parser parseOn: aStream.	aStream position: position.	^ element isPetitFailure		ifFalse: [ PPFailure message: '' at: aStream position ]! !!PPNotParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/13/2009 14:17'!displayDescription	^ 'not'! !!PPNotParser methodsFor: '*petitgui-accessing' stamp: 'lr 11/11/2009 21:09'!exampleOn: aStream! !